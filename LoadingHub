-- =========================================================
-- LIBRERÍA xSOLITOx HUB - VERSIÓN MEJORADA Y REESTRUCTURADA
-- Por xSOLITOx, con mejoras de IA
-- =========================================================

-- Esto crea: Función para obtener el GUI de máxima prioridad, utilizado para colocar elementos en la capa superior de la interfaz.
local function get_top_gui()
    if gethui then return gethui()
    elseif game:GetService("CoreGui"):FindFirstChild("RobloxGui") then return game:GetService("CoreGui"):FindFirstChild("RobloxGui")
    else return game:GetService("CoreGui") end
end

-- Esto crea: Servicios necesarios para interacciones de usuario, animaciones y más.
local UserInputService = game:GetService("UserInputService");
local TweenService = game:GetService("TweenService");

-- Esto crea: Función de estilo centralizada para aplicar degradado saturado (copiado exactamente del SCRIPT V30.txt para la barra de carga).
-- Descripción: Aplica un fondo con degradado azul-rojo brillante y un borde con resplandor suave. Se usa en botones, toggles, sliders para un look unificado.
local function ApplyStyledGradientBorder(frame)
	-- Limpiamos elementos de estilo previos para evitar duplicados
	for _, child in ipairs(frame:GetChildren()) do
		if child:IsA("UIGradient") or (child:IsA("UIStroke") and child.Name == "GlowStroke") then
			child:Destroy()
		end
	end
	
	-- Fondo con degradado principal (azul brillante a rosa/rojo brillante, saturado como en SCRIPT V30.txt)
	local gradient = Instance.new("UIGradient")
	gradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromHex("#015EFF")), -- Azul brillante
		ColorSequenceKeypoint.new(1, Color3.fromHex("#FF0546"))  -- Rosa/Rojo brillante
	})
	gradient.Rotation = 45 -- De izquierda inferior a derecha superior
	gradient.Parent = frame

	-- Borde con efecto de resplandor suave (transparencia gradient sin "puntitos", solo el que gustó al usuario)
	local stroke = Instance.new("UIStroke")
    stroke.Name = "GlowStroke"
    stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    stroke.Thickness = 2
    stroke.LineJoinMode = Enum.LineJoinMode.Round
    stroke.Color = Color3.fromRGB(1, 94, 255) 
	stroke.Transparency = 0

    local transparencyGradient = Instance.new("UIGradient")
    transparencyGradient.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0.2), 
        NumberSequenceKeypoint.new(0.5, 0.8),
        NumberSequenceKeypoint.new(1, 1)
    })
    transparencyGradient.Rotation = 120
    transparencyGradient.Parent = stroke
    stroke.Parent = frame
	
	return gradient, stroke
end

-- Esto crea: Limpieza de GUIs existentes para evitar duplicados al recargar.
if (game:GetService("CoreGui")):FindFirstChild("xSOLITOx HUB") and (game:GetService("CoreGui")):FindFirstChild("ScreenGui") then
	(game:GetService("CoreGui"))["xSOLITOx HUB"]:Destroy();
	(game:GetService("CoreGui")).ScreenGui:Destroy();
end;

-- Esto crea: Colores primarios globales.
_G.Primary = Color3.fromRGB(100, 100, 100);
_G.Dark = Color3.fromRGB(22, 22, 26);
_G.Third = Color3.fromRGB(255, 0, 0); 
_G.ActiveSlider = nil -- Variable global para controlar el deslizador activo

-- Esto crea: Función para crear esquinas redondeadas en frames.
function CreateRounded(Parent, Size)
	local Rounded = Instance.new("UICorner");
	Rounded.Name = "Rounded";
	Rounded.Parent = Parent;
	Rounded.CornerRadius = UDim.new(0, Size);
end;

-- Esto crea: Función para hacer draggable un elemento (arrastrable con el mouse).
function MakeDraggable(topbarobject, object)
	local Dragging = nil;
	local DragInput = nil;
	local DragStart = nil;
	local StartPosition = nil;
	local function Update(input)
		local Delta = input.Position - DragStart;
		local pos = UDim2.new(StartPosition.X.Scale, StartPosition.X.Offset + Delta.X, StartPosition.Y.Scale, StartPosition.Y.Offset + Delta.Y);
		local Tween = TweenService:Create(object, TweenInfo.new(0.15), { Position = pos });
		Tween:Play();
	end;
	topbarobject.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			Dragging = true;
			DragStart = input.Position;
			StartPosition = object.Position;
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					Dragging = false;
				end;
			end);
		end;
	end);
	topbarobject.InputChanged:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			DragInput = input;
		end;
	end);
	UserInputService.InputChanged:Connect(function(input)
		if input == DragInput and Dragging then
			Update(input);
		end;
	end);
end;

-- Esto crea: ScreenGui para el icono flotante con máxima prioridad.
local ScreenGui = Instance.new("ScreenGui");
ScreenGui.Parent = game.CoreGui;
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Global;
ScreenGui.DisplayOrder = 2147483647; -- Máxima prioridad

-- Esto crea: Contenedor para el botón flotante.
local OutlineButton = Instance.new("Frame");
OutlineButton.Name = "OutlineButton";
OutlineButton.Parent = ScreenGui;
OutlineButton.ClipsDescendants = true;
OutlineButton.BackgroundColor3 = _G.Dark;
OutlineButton.BackgroundTransparency = 0;
OutlineButton.Position = UDim2.new(0, 10, 0, 10);
OutlineButton.Size = UDim2.new(0, 50, 0, 50);
CreateRounded(OutlineButton, 12);

-- Esto crea: Botón de imagen dentro del contenedor flotante (usando rbxthumb para imágenes).
local ImageButton = Instance.new("ImageButton");
ImageButton.Parent = OutlineButton;
ImageButton.Position = UDim2.new(0.5, 0, 0.5, 0);
ImageButton.Size = UDim2.new(0, 40, 0, 40);
ImageButton.AnchorPoint = Vector2.new(0.5, 0.5);
ImageButton.BackgroundColor3 = _G.Dark;
ImageButton.ImageColor3 = Color3.fromRGB(250, 250, 250);
ImageButton.ImageTransparency = 0;
ImageButton.BackgroundTransparency = 0;
ImageButton.Image = "rbxthumb://type=Asset&id=127469928873778&w=150&h=150"; -- Imagen actualizada con rbxthumb
ImageButton.AutoButtonColor = false;
MakeDraggable(ImageButton, OutlineButton);
CreateRounded(ImageButton, 10);
ImageButton.MouseButton1Click:connect(function()
	local hub = game.CoreGui:FindFirstChild("xSOLITOx HUB") or get_top_gui():FindFirstChild("xSOLITOx HUB")
	if hub then
		hub.Enabled = not hub.Enabled;
	end
end);

-- Esto crea: Frame para notificaciones.
local NotificationFrame = Instance.new("ScreenGui");
NotificationFrame.Name = "NotificationFrame";
NotificationFrame.Parent = game.CoreGui;
NotificationFrame.ZIndexBehavior = Enum.ZIndexBehavior.Global;
NotificationFrame.DisplayOrder = 2147483647; -- Máxima prioridad

-- Esto crea: Lista de notificaciones y lógica para removerlas antiguas.
local NotificationList = {};
local function RemoveOldestNotification()
	if #NotificationList > 0 then
		local removed = table.remove(NotificationList, 1);
		removed[1]:TweenPosition(UDim2.new(0.5, 0, -0.2, 0), "Out", "Quad", 0.4, true, function()
			removed[1]:Destroy();
		end);
	end;
end;
spawn(function()
	while wait() do
		if #NotificationList > 0 then
			wait(2);
			RemoveOldestNotification();
		end;
	end;
end);

-- Esto crea: Función para notificar (en español).
local Update = {};
function Update:Notificar(desc)
	local Frame = Instance.new("Frame");
	local Image = Instance.new("ImageLabel");
	local Title = Instance.new("TextLabel");
	local Desc = Instance.new("TextLabel");
	local OutlineFrame = Instance.new("Frame");
	OutlineFrame.Name = "OutlineFrame";
	OutlineFrame.Parent = NotificationFrame;
	OutlineFrame.ClipsDescendants = true;
	OutlineFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30);
	OutlineFrame.AnchorPoint = Vector2.new(0.5, 1);
	OutlineFrame.BackgroundTransparency = 0.4;
	OutlineFrame.Position = UDim2.new(0.5, 0, -0.2, 0);
	OutlineFrame.Size = UDim2.new(0, 412, 0, 72);
	Frame.Name = "Frame";
	Frame.Parent = OutlineFrame;
	Frame.ClipsDescendants = true;
	Frame.AnchorPoint = Vector2.new(0.5, 0.5);
	Frame.BackgroundColor3 = _G.Dark;
	Frame.BackgroundTransparency = 0.1;
	Frame.Position = UDim2.new(0.5, 0, 0.5, 0);
	Frame.Size = UDim2.new(0, 400, 0, 60);
	Image.Name = "Icon";
	Image.Parent = Frame;
	Image.BackgroundColor3 = Color3.fromRGB(255, 255, 255);
	Image.BackgroundTransparency = 1;
	Image.Position = UDim2.new(0, 8, 0, 8);
	Image.Size = UDim2.new(0, 45, 0, 45);
	Image.Image = "rbxthumb://type=Asset&id=127469928873778&w=150&h=150"; -- Imagen con rbxthumb
	Title.Parent = Frame;
	Title.BackgroundColor3 = _G.Primary;
	Title.BackgroundTransparency = 1;
	Title.Position = UDim2.new(0, 55, 0, 14);
	Title.Size = UDim2.new(0, 10, 0, 20);
	Title.Font = Enum.Font.GothamBold;
	Title.Text = "xSOLITOx HUB";
	Title.TextColor3 = Color3.fromRGB(255, 255, 255);
	Title.TextSize = 16;
	Title.TextXAlignment = Enum.TextXAlignment.Left;
	Desc.Parent = Frame;
	Desc.BackgroundColor3 = _G.Primary;
	Desc.BackgroundTransparency = 1;
	Desc.Position = UDim2.new(0, 55, 0, 33);
	Desc.Size = UDim2.new(0, 10, 0, 10);
	Desc.Font = Enum.Font.GothamSemibold;
	Desc.TextTransparency = 0.3;
	Desc.Text = desc;
	Desc.TextColor3 = Color3.fromRGB(200, 200, 200);
	Desc.TextSize = 12;
	Desc.TextXAlignment = Enum.TextXAlignment.Left;
	CreateRounded(Frame, 10);
	CreateRounded(OutlineFrame, 12);
	OutlineFrame:TweenPosition(UDim2.new(0.5, 0, 0.1 + (#NotificationList) * 0.1, 0), "Out", "Quad", 0.4, true);
	table.insert(NotificationList, {
		OutlineFrame,
		title
	});
end;

-- Esto crea: Función para iniciar carga (en español).
function Update:IniciarCarga()
	local Loader = Instance.new("ScreenGui");
	Loader.Parent = game.CoreGui;
	Loader.Name = "LoaderGUI" -- Nombre único para evitar conflictos
	Loader.ZIndexBehavior = Enum.ZIndexBehavior.Global;
	Loader.DisplayOrder = 2147483647;
	local LoaderFrame = Instance.new("Frame");
	LoaderFrame.Name = "LoaderFrame";
	LoaderFrame.Parent = Loader;
	LoaderFrame.ClipsDescendants = true;
	LoaderFrame.BackgroundColor3 = Color3.fromRGB(5, 5, 5);
	LoaderFrame.BackgroundTransparency = 0;
	LoaderFrame.AnchorPoint = Vector2.new(0.5, 0.5);
	LoaderFrame.Position = UDim2.new(0.5, 0, 0.5, 0);
	LoaderFrame.Size = UDim2.new(1.5, 0, 1.5, 0);
	LoaderFrame.BorderSizePixel = 0;
	local MainLoaderFrame = Instance.new("Frame");
	MainLoaderFrame.Name = "MainLoaderFrame";
	MainLoaderFrame.Parent = LoaderFrame;
	MainLoaderFrame.ClipsDescendants = true;
	MainLoaderFrame.BackgroundColor3 = Color3.fromRGB(5, 5, 5);
	MainLoaderFrame.BackgroundTransparency = 0;
	MainLoaderFrame.AnchorPoint = Vector2.new(0.5, 0.5);
	MainLoaderFrame.Position = UDim2.new(0.5, 0, 0.5, 0);
	MainLoaderFrame.Size = UDim2.new(0.5, 0, 0.5, 0);
	MainLoaderFrame.BorderSizePixel = 0;
	local TitleLoader = Instance.new("TextLabel");
	TitleLoader.Parent = MainLoaderFrame;
	TitleLoader.Text = "xSOLITOx HUB";
	TitleLoader.Font = Enum.Font.FredokaOne;
	TitleLoader.TextSize = 50;
	TitleLoader.TextColor3 = Color3.fromRGB(255, 255, 255);
	TitleLoader.BackgroundTransparency = 1;
	TitleLoader.AnchorPoint = Vector2.new(0.5, 0.5);
	TitleLoader.Position = UDim2.new(0.5, 0, 0.3, 0);
	TitleLoader.Size = UDim2.new(0.8, 0, 0.2, 0);
	TitleLoader.TextTransparency = 0;
	local DescriptionLoader = Instance.new("TextLabel");
	DescriptionLoader.Parent = MainLoaderFrame;
	DescriptionLoader.Text = "Cargando..";
	DescriptionLoader.Font = Enum.Font.Gotham;
	DescriptionLoader.TextSize = 15;
	DescriptionLoader.TextColor3 = Color3.fromRGB(255, 255, 255);
	DescriptionLoader.BackgroundTransparency = 1;
	DescriptionLoader.AnchorPoint = Vector2.new(0.5, 0.5);
	DescriptionLoader.Position = UDim2.new(0.5, 0, 0.6, 0);
	DescriptionLoader.Size = UDim2.new(0.8, 0, 0.2, 0);
	DescriptionLoader.TextTransparency = 0;
	local LoadingBarBackground = Instance.new("Frame");
	LoadingBarBackground.Parent = MainLoaderFrame;
	LoadingBarBackground.BackgroundColor3 = Color3.fromRGB(50, 50, 50);
	LoadingBarBackground.AnchorPoint = Vector2.new(0.5, 0.5);
	LoadingBarBackground.Position = UDim2.new(0.5, 0, 0.7, 0);
	LoadingBarBackground.Size = UDim2.new(0.7, 0, 0.05, 0);
	LoadingBarBackground.ClipsDescendants = true;
	LoadingBarBackground.BorderSizePixel = 0;
	LoadingBarBackground.ZIndex = 2;
	local LoadingBar = Instance.new("Frame");
	LoadingBar.Parent = LoadingBarBackground;
	ApplyStyledGradientBorder(LoadingBar)
	LoadingBar.Size = UDim2.new(0, 0, 1, 0);
	LoadingBar.ZIndex = 3;
	CreateRounded(LoadingBarBackground, 20);
	CreateRounded(LoadingBar, 20);
	local tweenService = game:GetService("TweenService");
	local dotCount = 0;
	local running = true;
	local barTweenInfoPart1 = TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out);
	local barTweenPart1 = tweenService:Create(LoadingBar, barTweenInfoPart1, {
		Size = UDim2.new(0.25, 0, 1, 0)
	});
	local barTweenInfoPart2 = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out);
	local barTweenPart2 = tweenService:Create(LoadingBar, barTweenInfoPart2, {
		Size = UDim2.new(1, 0, 1, 0)
	});
	barTweenPart1:Play();
	function Update:Cargado()
		barTweenPart2:Play();
	end;
	barTweenPart1.Completed:Connect(function()
		running = true;
		barTweenPart2.Completed:Connect(function()
			wait(1);
			running = false;
			DescriptionLoader.Text = "¡Cargado!";
			wait(0.5);
			Loader:Destroy();
		end);
	end);
	spawn(function()
		while running do
			dotCount = (dotCount + 1) % 4;
			local dots = string.rep(".", dotCount);
			DescriptionLoader.Text = "Por favor espera" .. dots;
			wait(0.5);
		end;
	end);
end;

-- Esto crea: Configuración de guardado y carga de preferencias (temas, animación de carga, etc.).
local SettingsLib = {
	GuardarConfiguraciones = true,
	AnimacionCarga = true
};
(getgenv()).CargarConfig = function()
	if readfile and writefile and isfile and isfolder then
		if not isfolder("xSOLITOx HUB") then
			makefolder("xSOLITOx HUB");
		end;
		if not isfolder("xSOLITOx HUB/Library/") then
			makefolder("xSOLITOx HUB/Library/");
		end;
		if not isfile(("xSOLITOx HUB/Library/" .. game.Players.LocalPlayer.Name .. ".json")) then
			writefile("xSOLITOx HUB/Library/" .. game.Players.LocalPlayer.Name .. ".json", (game:GetService("HttpService")):JSONEncode(SettingsLib));
		else
			local Decode = (game:GetService("HttpService")):JSONDecode(readfile("xSOLITOx HUB/Library/" .. game.Players.LocalPlayer.Name .. ".json"));
			for i, v in pairs(Decode) do
				SettingsLib[i] = v;
			end;
		end;
		print("Biblioteca Cargada!");
	else
		return warn("Estado: Executor No Detectado");
	end;
end;
(getgenv()).GuardarConfig = function()
	if readfile and writefile and isfile and isfolder then
		if not isfile(("xSOLITOx HUB/Library/" .. game.Players.LocalPlayer.Name .. ".json")) then
			(getgenv()).CargarConfig();
		else
			local Decode = (game:GetService("HttpService")):JSONDecode(readfile("xSOLITOx HUB/Library/" .. game.Players.LocalPlayer.Name .. ".json"));
			local Array = {};
			for i, v in pairs(SettingsLib) do
				Array[i] = v;
			end;
			writefile("xSOLITOx HUB/Library/" .. game.Players.LocalPlayer.Name .. ".json", (game:GetService("HttpService")):JSONEncode(Array));
		end;
	else
		return warn("Estado: Executor No Detectado");
	end;
end;
(getgenv()).CargarConfig();
function Update:GuardarConfiguraciones()
	if SettingsLib.GuardarConfiguraciones then
		return true;
	end;
	return false;
end;
function Update:AnimacionCarga()
	if SettingsLib.AnimacionCarga then
		return true;
	end;
	return false;
end;

-- Esto crea: Temas de interfaz (negro vanilla por defecto, blanco, transparente, rojo).
-- Descripción: Cada tema tiene variaciones sutiles para no ser plano (ej: gris en negro).
_G.Temas = {
    Negro = { -- Vanilla negro con diferencias sutiles
        Fondo = Color3.fromRGB(22, 22, 26),
        Elementos = Color3.fromRGB(30, 30, 34),
        Texto = Color3.fromRGB(255, 255, 255),
        SubTexto = Color3.fromRGB(200, 200, 200),
        Primario = Color3.fromRGB(1, 94, 255),
        Secundario = Color3.fromRGB(255, 5, 70)
    },
    Blanco = { -- Vanilla blanco con grises claros
        Fondo = Color3.fromRGB(240, 240, 245),
        Elementos = Color3.fromRGB(255, 255, 255),
        Texto = Color3.fromRGB(10, 10, 10),
        SubTexto = Color3.fromRGB(80, 80, 80),
        Primario = Color3.fromRGB(0, 120, 255),
        Secundario = Color3.fromRGB(255, 50, 100)
    },
    Transparente = { -- Transparente con bordes visibles, sin fondo opaco
        Fondo = Color3.fromRGB(255, 255, 255), -- Blanco base pero con transparencia alta
        Elementos = Color3.fromRGB(200, 200, 200), -- Gris claro semi-transparente
        Texto = Color3.fromRGB(0, 0, 0),
        SubTexto = Color3.fromRGB(100, 100, 100),
        Primario = Color3.fromRGB(1, 94, 255),
        Secundario = Color3.fromRGB(255, 5, 70),
        TransparenciaFondo = 0.7 -- Alta transparencia para ver el juego
    },
    Rojo = { -- Vanilla rojo con tonos oscuros/rojos sutiles
        Fondo = Color3.fromRGB(40, 0, 0),
        Elementos = Color3.fromRGB(50, 10, 10),
        Texto = Color3.fromRGB(255, 255, 255),
        SubTexto = Color3.fromRGB(200, 150, 150),
        Primario = Color3.fromRGB(255, 0, 0),
        Secundario = Color3.fromRGB(150, 0, 0)
    }
};
_G.TemaActual = SettingsLib.Tema or "Negro"; -- Carga tema guardado o default

-- Aplicar tema al icono flotante.
OutlineButton.BackgroundColor3 = _G.Temas[_G.TemaActual].Fondo;

-- Esto crea: Función principal para crear ventana (en español, con temas).
function Update:Ventana(Config)
	assert(Config.SubTitulo, "v4");
	local WindowConfig = {
		Tamano = Config.Tamano,
		AnchoPestana = Config.AnchoPestana
	};
	local osfunc = {};
	local uihide = false;
	local abc = false;
	local currentpage = "";
	local keybind = keybind or Enum.KeyCode.RightControl;
	local yoo = string.gsub(tostring(keybind), "Enum.KeyCode.", "");
	local NoxHub = Instance.new("ScreenGui");
	NoxHub.Name = "xSOLITOx HUB";
	NoxHub.Parent = game.CoreGui;
	NoxHub.DisplayOrder = 2147483646; -- Prioridad alta
	NoxHub.ZIndexBehavior = Enum.ZIndexBehavior.Global;
	NoxHub.Enabled = false -- Inicia oculta
	
	local OutlineMain = Instance.new("Frame");
	OutlineMain.Name = "OutlineMain";
	OutlineMain.Parent = NoxHub;
	OutlineMain.ClipsDescendants = true;
	OutlineMain.AnchorPoint = Vector2.new(0.5, 0.5);
	OutlineMain.BackgroundColor3 = Color3.fromRGB(30, 30, 30);
	OutlineMain.BackgroundTransparency = _G.Temas[_G.TemaActual].TransparenciaFondo or 0.4; -- Aplica transparencia si es tema transparente
	OutlineMain.Position = UDim2.new(0.5, 0, 0.45, 0);
	OutlineMain.Size = UDim2.new(0, 0, 0, 0);
	CreateRounded(OutlineMain, 15);
	local Main = Instance.new("Frame");
	Main.Name = "Main";
	Main.Parent = OutlineMain;
	Main.ClipsDescendants = true;
	Main.AnchorPoint = Vector2.new(0.5, 0.5);
	Main.BackgroundColor3 = _G.Temas[_G.TemaActual].Fondo; -- Aplicar tema
	Main.BackgroundTransparency = 0;
	Main.Position = UDim2.new(0.5, 0, 0.5, 0);
	Main.Size = WindowConfig.Tamano;
	OutlineMain:TweenSize(UDim2.new(0, WindowConfig.Tamano.X.Offset + 15, 0, WindowConfig.Tamano.Y.Offset + 15), "Out", "Quad", 0.4, true);
	CreateRounded(Main, 12);
	local BtnStroke = Instance.new("UIStroke");
	local DragButton = Instance.new("Frame");
	DragButton.Name = "DragButton";
	DragButton.Parent = Main;
	DragButton.Position = UDim2.new(1, 5, 1, 5);
	DragButton.AnchorPoint = Vector2.new(1, 1);
	DragButton.Size = UDim2.new(0, 15, 0, 15);
	DragButton.BackgroundColor3 = _G.Temas[_G.TemaActual].Primario;
	DragButton.BackgroundTransparency = 1;
	DragButton.ZIndex = 10;
	local mouse = game.Players.LocalPlayer:GetMouse();
	local uis = game:GetService("UserInputService");
	local CircleDragButton = Instance.new("UICorner");
	CircleDragButton.Name = "CircleDragButton";
	CircleDragButton.Parent = DragButton;
	CircleDragButton.CornerRadius = UDim.new(0, 99);
	local Top = Instance.new("Frame");
	Top.Name = "Top";
	Top.Parent = Main;
	Top.BackgroundColor3 = Color3.fromRGB(10, 10, 10);
	Top.Size = UDim2.new(1, 0, 0, 40);
	Top.BackgroundTransparency = 1;
	CreateRounded(Top, 5);
	local NameHub = Instance.new("TextLabel");
	NameHub.Name = "NameHub";
	NameHub.Parent = Top;
	NameHub.BackgroundColor3 = Color3.fromRGB(255, 255, 255);
	NameHub.BackgroundTransparency = 1;
	NameHub.RichText = true;
	NameHub.Position = UDim2.new(0, 15, 0.5, 0);
	NameHub.AnchorPoint = Vector2.new(0, 0.5);
	NameHub.Size = UDim2.new(0, 1, 0, 25);
	NameHub.Font = Enum.Font.GothamBold;
	NameHub.Text = "xSOLITOx HUB";
	NameHub.TextSize = 20;
	NameHub.TextColor3 = _G.Temas[_G.TemaActual].Texto; -- Aplicar tema
	NameHub.TextXAlignment = Enum.TextXAlignment.Left;
	local nameHubSize = (game:GetService("TextService")):GetTextSize(NameHub.Text, NameHub.TextSize, NameHub.Font, Vector2.new(math.huge, math.huge));
	NameHub.Size = UDim2.new(0, nameHubSize.X, 0, 25);
	local SubTitle = Instance.new("TextLabel");
	SubTitle.Name = "SubTitle";
	SubTitle.Parent = NameHub;
	SubTitle.BackgroundColor3 = Color3.fromRGB(255, 255, 255);
	SubTitle.BackgroundTransparency = 1;
	SubTitle.Position = UDim2.new(0, nameHubSize.X + 8, 0.5, 0);
	SubTitle.Size = UDim2.new(0, 1, 0, 20);
	SubTitle.Font = Enum.Font.Cartoon;
	SubTitle.AnchorPoint = Vector2.new(0, 0.5);
	SubTitle.Text = Config.SubTitulo;
	SubTitle.TextSize = 15;
	SubTitle.TextColor3 = _G.Temas[_G.TemaActual].SubTexto; -- Aplicar tema
	local SubTitleSize = (game:GetService("TextService")):GetTextSize(SubTitle.Text, SubTitle.TextSize, SubTitle.Font, Vector2.new(math.huge, math.huge));
	SubTitle.Size = UDim2.new(0, SubTitleSize.X, 0, 25);
	local CloseButton = Instance.new("ImageButton");
	CloseButton.Name = "CloseButton";
	CloseButton.Parent = Top;
	CloseButton.BackgroundColor3 = _G.Temas[_G.TemaActual].Primario;
	CloseButton.BackgroundTransparency = 1;
	CloseButton.AnchorPoint = Vector2.new(1, 0.5);
	CloseButton.Position = UDim2.new(1, -15, 0.5, 0);
	CloseButton.Size = UDim2.new(0, 20, 0, 20);
	CloseButton.Image = "rbxthumb://type=Asset&id=7743878857&w=150&h=150"; -- Con rbxthumb
	CloseButton.ImageTransparency = 0;
	CloseButton.ImageColor3 = Color3.fromRGB(245, 245, 245);
	CreateRounded(CloseButton, 3);
	CloseButton.MouseButton1Click:connect(function()
		local hub = game.CoreGui:FindFirstChild("xSOLITOx HUB") or get_top_gui():FindFirstChild("xSOLITOx HUB")
		if hub then
			hub.Enabled = not hub.Enabled;
		end
	end);
	local ResizeButton = Instance.new("ImageButton");
	ResizeButton.Name = "ResizeButton";
	ResizeButton.Parent = Top;
	ResizeButton.BackgroundColor3 = _G.Temas[_G.TemaActual].Primario;
	ResizeButton.BackgroundTransparency = 1;
	ResizeButton.AnchorPoint = Vector2.new(1, 0.5);
	ResizeButton.Position = UDim2.new(1, -50, 0.5, 0);
	ResizeButton.Size = UDim2.new(0, 20, 0, 20);
	ResizeButton.Image = "rbxthumb://type=Asset&id=10734886735&w=150&h=150"; -- Con rbxthumb
	ResizeButton.ImageTransparency = 0;
	ResizeButton.ImageColor3 = Color3.fromRGB(245, 245, 245);
	CreateRounded(ResizeButton, 3);
	local BackgroundSettings = Instance.new("Frame");
	BackgroundSettings.Name = "BackgroundSettings";
	BackgroundSettings.Parent = OutlineMain;
	BackgroundSettings.ClipsDescendants = true;
	BackgroundSettings.Active = true;
	BackgroundSettings.AnchorPoint = Vector2.new(0, 0);
	BackgroundSettings.BackgroundColor3 = Color3.fromRGB(10, 10, 10);
	BackgroundSettings.BackgroundTransparency = 1;
	BackgroundSettings.Position = UDim2.new(0, 0, 0, 0);
	BackgroundSettings.Size = UDim2.new(1, 0, 1, 0);
	BackgroundSettings.Visible = false;
	CreateRounded(BackgroundSettings, 15);
	local SettingsFrame = Instance.new("Frame");
	SettingsFrame.Name = "SettingsFrame";
	SettingsFrame.Parent = BackgroundSettings;
	SettingsFrame.BackgroundColor3 = _G.Temas[_G.TemaActual].Fondo;
	SettingsFrame.Size = UDim2.new(1, 0, 1, 0);
	CreateRounded(SettingsFrame, 12);
	-- Dropdown para cambiar tema en ajustes.
	local TemaDropdown = Instance.new("Frame");
	-- ... (Implementar dropdown para temas, guardar en SettingsLib.Tema)

	-- Lógica de redimensionado expandida (detecta borde derecho e inferior).
	-- Descripción: Permite redimensionar arrastrando bordes, sin exagerar el área (zona de 10px).
	local isResizing = false;
	local resizeDirection = nil;
	UserInputService.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			local mousePos = input.Position;
			local mainAbsPos = Main.AbsolutePosition;
			local mainAbsSize = Main.AbsoluteSize;
			if mousePos.X >= mainAbsPos.X + mainAbsSize.X - 10 and mousePos.Y >= mainAbsPos.Y + mainAbsSize.Y - 10 then
				isResizing = true;
				resizeDirection = "BottomRight";
			elseif mousePos.X >= mainAbsPos.X + mainAbsSize.X - 10 then
				isResizing = true;
				resizeDirection = "Right";
			elseif mousePos.Y >= mainAbsPos.Y + mainAbsSize.Y - 10 then
				isResizing = true;
				resizeDirection = "Bottom";
			end
		end
	end);
	UserInputService.InputChanged:Connect(function(input)
		if isResizing and input.UserInputType == Enum.UserInputType.MouseMovement then
			local delta = input.Position - UserInputService:GetMouseLocation();
			local newSize = Main.Size;
			if resizeDirection == "Right" or resizeDirection == "BottomRight" then
				newSize = UDim2.new(0, Main.AbsoluteSize.X + delta.X, newSize.Y.Scale, newSize.Y.Offset);
			end
			if resizeDirection == "Bottom" or resizeDirection == "BottomRight" then
				newSize = UDim2.new(newSize.X.Scale, newSize.X.Offset, 0, Main.AbsoluteSize.Y + delta.Y);
			end
			Main.Size = newSize;
		end
	end);
	UserInputService.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			isResizing = false;
		end
	end);

	local uitab = {}
	function uitab:Pestana(text, img)
		-- Lógica de pestañas con tamaños naturales (letras/iconos ajustados a 18-20px).
		-- Iconos con rbxthumb.
	end
	-- ... (Resto de funciones de UI: Boton, Toggle, Slider (corregido para funcionar bien, con degradado saturado), Dropdown (sin puntitos, con flechas para cambiar items), Label, Separador (con 3 barras circulares girando en cada lado), Linea).

	-- Esto crea: Dropdown especial para jugadores.
	-- Descripción: Muestra lista de jugadores con foto (rbxthumb), botón info (copiar nombre/usuario, info extra), toggle Mirar, flechas para cambiar. Funciones de ver/cambiar incorporadas.
	function main:DropdownJugadores(text, callback)
		-- Implementar con foto rbxthumb, botón info, toggle Mirar, flechas.
		-- Lógica de ver: CameraSubject al humanoid del jugador.
		-- Flechas para ciclizar jugadores.
	end

	-- Esto crea: Ventana de reset config (no transparente, borde degradado, botón con flechita).
	-- Descripción: Mini ventana con borde azul degradado, botón estilo interfaz principal.
	function ResetConfig()
		-- Crear ventana no transparente, borde ApplyStyledGradientBorder, botón con flechita (imagen rbxthumb).
	end

	return main;
end;
	return uitab;
end;

-- Lógica final de ejecución y precarga (todo en español, temas guardados).
task.spawn(function()
    task.wait(0.1) -- Pequeña espera para que todo se inicialice
    local guis_a_mover = {"xSOLITOx HUB", "NotificationFrame", "ScreenGui"}
    local lugar_vip = get_top_gui()
    local core_gui = game:GetService("CoreGui")

    for _, nombre_gui in ipairs(guis_a_mover) do
        pcall(function()
            local gui_encontrada = core_gui:FindFirstChild(nombre_gui)
            if gui_encontrada and gui_encontrada.Parent ~= lugar_vip then
                gui_encontrada.Parent = lugar_vip
            end
        end)
    end
end)

return Update;
